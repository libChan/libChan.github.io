<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Xinru Shan</title>
    <link>https://libchan.github.io/post/</link>
      <atom:link href="https://libchan.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sun, 23 Jul 2023 23:09:59 +0800</lastBuildDate>
    <image>
      <url>https://libchan.github.io/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>Posts</title>
      <link>https://libchan.github.io/post/</link>
    </image>
    
    <item>
      <title>[DDIA] 数据复制</title>
      <link>https://libchan.github.io/post/ddia_data_copy/</link>
      <pubDate>Sun, 23 Jul 2023 23:09:59 +0800</pubDate>
      <guid>https://libchan.github.io/post/ddia_data_copy/</guid>
      <description>&lt;h1 id=&#34;数据复制&#34;&gt;数据复制&lt;/h1&gt;
&lt;h2 id=&#34;数据复制的目的&#34;&gt;数据复制的目的&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;高可用：一个节点挂掉时，整个系统还有其他节点可以工作。&lt;/li&gt;
&lt;li&gt;低延迟：使数据在地理位置上更靠近用户，降低网络延迟。&lt;/li&gt;
&lt;li&gt;高吞吐：多个节点可访问，提高系统整体吞吐量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;主从复制&#34;&gt;主从复制&lt;/h2&gt;
&lt;p&gt;主从复制指，系统有一个主节点，多个从节点，写请求只发送给主节点，主写入本地后，发送日志给从节点，从节点进行更新。主节点和从节点都可以接收读请求。
主从复制需要考虑的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调节同步和异步复制的节点比例，这会影响系统的吞吐，延迟，数据更新比例等。&lt;/li&gt;
&lt;li&gt;从节点新增/恢复。从本地或向主节点请求某时刻的日志snapshot，执行后继续从主节点同步后续日志。&lt;/li&gt;
&lt;li&gt;主节点挂掉：确认主节点挂掉的条件，leader选举，重新配置主节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;日志复制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于语句：将主节点执行的语句发送到从节点。&lt;/li&gt;
&lt;li&gt;基于预写日志（WAL）：对于追加写到日志的，可以将日志发送给从节点。&lt;em&gt;缺点：日志描述的数据非常底层。（不理解）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;基于行的逻辑日志：将复制和存储方式分离。复制日志是一种逻辑日志，并不真正实现存储。MySQL的二进制binlog是采用这种方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;复制滞后可能出现的问题&#34;&gt;复制滞后可能出现的问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;读自己的写不一致：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于客户端有权限修改的内容，读主节点，否则读从节点。但对于大家都有权限修改的内容，就失效了。&lt;/li&gt;
&lt;li&gt;客户端记录写的时间，读的时间小于1min，读主节点，否则读从节点。这对阈值的设置要求比较高。&lt;/li&gt;
&lt;li&gt;客户端维护最近写的时间戳，附带在读请求。当节点包含该时间戳的更新，才返回结果。但理论上不同节点的时间无法完全一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;单调读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前一次读的内容新于后一次读，比如第一次看到数据，再刷新数据消失。可能是由于第一次读的节点数据更新了，第二次读的节点数据未更新。&lt;/p&gt;
&lt;p&gt;单调读一致性是指，用户多次读取，不会看到版本回滚的现象。&lt;/p&gt;
&lt;p&gt;实现单调读的方法：确保用户每次都读一个节点，可以对用户id进行hash，路由到节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前缀一致读：&lt;/strong&gt;
对于一系列按照顺序发生的写请求，读取时也需要按照写入顺序读取。&lt;/p&gt;
&lt;h2 id=&#34;多主复制&#34;&gt;多主复制&lt;/h2&gt;
&lt;p&gt;每个主节点都可以接受写请求，同时是其他主节点的从节点。多主节点的结构&lt;strong&gt;适用于多数据中心&lt;/strong&gt;的场景。多数据中心一般在不同region，为了靠近用户。但如果只有一个主节点，在一个数据中心，则失去了按region分配的意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据中心内主从模型，所有数据中心构成多主模型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多主复制的优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多主提高整个系统的吞吐&lt;/li&gt;
&lt;li&gt;更高容错，一个主节点挂掉，数据中心内再选举一个主节点，不需要垮数据中心选举，不会造成网络负担大。&lt;/li&gt;
&lt;li&gt;多主节点之间采用异步复制，网络失效影响较小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多主复制的问题：不同数据中心同时修改相同的数据，需要处理写冲突。解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免冲突：在应用层避免写入冲突。例如用户更新自己的数据，写请求只路由到特定的数据中心。但如果数据中心故障，或者用户去其他位置，则需要解决数据中心之间的冲突。&lt;/li&gt;
&lt;li&gt;收敛到一致状态：比如每个用户提供写入时间戳，按顺序写入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自动冲突解决：规则可能变得很复杂，有一些从数据结构和算法层面解决冲突的方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无冲突的复制数据类型（CRDT），可以由多个用户同时编辑，以内置方法解决冲突。&lt;/li&gt;
&lt;li&gt;可合并的持久数据结构：像Git一样跟踪版本，提出&lt;em&gt;三向合并功能&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;操作转换：是Etherpad和Google Docs的冲突解决算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;无主复制&#34;&gt;无主复制&lt;/h2&gt;
&lt;p&gt;没有主节点，去中心复制，每个节点都可以接受写请求。Amazon内部的Dynamo掀起一阵无主复制的热潮。&lt;/p&gt;
&lt;p&gt;无主节点系统的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读修复：client的读同时请求到多个节点，对比version，将version最新的作为结果。&lt;/li&gt;
&lt;li&gt;反熵：background进程扫描节点之间副本的差异，并复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Q: 怎么判断无主系统处理读写请求时，是最新状态？&lt;/p&gt;
&lt;p&gt;假设有n个节点，写入需要w个节点确认，读取需要r个节点确认，则w+r&amp;gt;n，读取的节点中一定包含最新值，w和r有overlap。将w和r成为法定票数写和法定票数读，用于判断读和写是否有效。&lt;/p&gt;
&lt;p&gt;Q: 如果此时系统因为一些原因，例如网络问题，导致无法满足w和r，怎么处理？&lt;/p&gt;
&lt;p&gt;可以采用sloppy quorum，允许w个写入和r个读，但可以不在指定的n个节点。这里应该是集群比较大，n不是全部节点数，有备用节点的情况。等问题修复好，再同步到n个节点。但在sloppy quorum下，即便满足w+r&amp;gt;n，也不保证读到最新值。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
